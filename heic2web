#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "Pillow",
#     "pillow_heif",
# ]
# ///
import argparse
import os
import sys
from PIL import Image
import pillow_heif

def convert_heic_file(heic_file, output_format='jpg', quality=95, force=False):
    """Convert a single HEIC file to specified format."""
    try:
        # Open HEIC file
        with Image.open(heic_file) as img:
            # Convert to appropriate color mode
            if output_format.lower() == 'jpg' and img.mode != 'RGB':
                img = img.convert('RGB')
            elif output_format.lower() == 'png' and img.mode == 'P':
                img = img.convert('RGBA')
            
            # Create output filename
            output_file = os.path.splitext(heic_file)[0] + f'.{output_format.lower()}'
            
            # Check if output file exists
            if os.path.exists(output_file) and not force:
                response = input(f"File {output_file} exists. Overwrite? (y/N): ")
                if response.lower() not in ['y', 'yes']:
                    print(f"Skipped {heic_file}")
                    return None
            
            # Save with appropriate format and settings
            if output_format.lower() == 'jpg':
                img.save(output_file, 'JPEG', quality=quality)
            elif output_format.lower() == 'webp':
                img.save(output_file, 'WebP', quality=quality)
            else:  # PNG
                img.save(output_file, 'PNG')
            
            print(f"Converted {heic_file} -> {output_file}")
            return True
            
    except Exception as e:
        print(f"Failed to convert {heic_file}: {str(e)}", file=sys.stderr)
        return False

def main():
    parser = argparse.ArgumentParser(
        description="Convert HEIC files to web-compatible formats (JPEG/PNG/WebP)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""Examples:
  %(prog)s image.HEIC                    # Convert to JPEG (default)
  %(prog)s -f png *.HEIC                 # Convert all to PNG format
  %(prog)s -f webp *.HEIC                # Convert all to WebP format
  %(prog)s -q 85 file.HEIC               # Convert with 85%% quality
  %(prog)s --force file.HEIC             # Overwrite existing files
        """
    )
    
    parser.add_argument(
        'files',
        nargs='+',
        help='HEIC files to convert'
    )
    
    parser.add_argument(
        '-f', '--format',
        choices=['jpg', 'png', 'webp'],
        default='jpg',
        help='Output format (default: jpg)'
    )
    
    parser.add_argument(
        '-q', '--quality',
        type=int,
        default=95,
        metavar='N',
        help='Quality 1-100 for JPEG/WebP (default: 95, ignored for PNG)'
    )
    
    parser.add_argument(
        '--force',
        action='store_true',
        help='Overwrite existing output files without prompting'
    )
    
    args = parser.parse_args()
    
    # Validate quality parameter
    if args.quality < 1 or args.quality > 100:
        print("Error: Quality must be between 1 and 100", file=sys.stderr)
        sys.exit(1)
    
    # Register HEIF opener with Pillow
    pillow_heif.register_heif_opener()
    
    # Filter out non-existent files and warn about them
    existing_files = []
    for file in args.files:
        if os.path.exists(file):
            existing_files.append(file)
        else:
            print(f"heic2web: {file}: No such file or directory", file=sys.stderr)
    
    if not existing_files:
        print("heic2web: No valid files to convert", file=sys.stderr)
        sys.exit(1)
    
    converted = 0
    failed = 0
    skipped = 0
    
    for heic_file in existing_files:
        result = convert_heic_file(heic_file, args.format, args.quality, args.force)
        if result is True:
            converted += 1
        elif result is False:
            failed += 1
        else:  # None means skipped
            skipped += 1
    
    # Print summary only if processing multiple files
    if len(existing_files) > 1:
        parts = []
        if converted > 0:
            parts.append(f"{converted} converted")
        if skipped > 0:
            parts.append(f"{skipped} skipped")
        if failed > 0:
            parts.append(f"{failed} failed")
        print(", ".join(parts))
    
    # Exit with error code if any conversions failed
    sys.exit(1 if failed > 0 else 0)

if __name__ == "__main__":
    main()
